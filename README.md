1. private修饰的方法可以通过反射访问，那么private的意义是什么
private设计为了表达封装而不是安全性，为了在常规java使用中提供访问约束。反射是一种hack技术。
2. java类初始化顺序
基类静态代码块和静态成员变量，子类静态代码块和静态成员变量，基类普通代码块和成员变量，基类构造函数。子类普通代码块和成员变量。子类构造函数。
代码块和成员变量的初始化顺序根据声明顺序。静态代码块和成员变量只会执行一次
3. 说一下方法区和永久区的关系
方法区是jvm规范中的定义，永久区是方法区的一种实现，比如jdk8中引入的元数据区
4. 一个java文件有三个类编译以后有几个类
三个类
局部变量不不赋值使用会报编译错误，为什么这样设计。
5. 局部变量没有赋值直接使用可能是程序员的疏忽，这样设计可以避免错误。
6. readwritwlock读写之间互斥吗？
读与读这间不互斥，只要有线程在写就互斥
7. semaphore拿到执行权的线程之间是否互斥
不互斥
8. b树和b+树有什么区别，分别解决什么问题，如何演化而来
b树和b+树都是数据库索引的实现方式。二叉树有退化现象，演化成平衡二叉树，为了减少遍历深度，演化为m叉平衡树。为了每一个节点多放key，进一步减少遍历深度所以引入b+树。
9. 写一个生产者消费者模式
lock+condition，java的blockingqueue就是典型的生产者和消费者模式
10. 写一个死锁
线程一拿到锁a后申请锁b，线程二拿到锁b后申请锁a
11. 如何定位cpu100%
使用visualvm将jvm的threaddump输出
12. string a=“ab” string b=“a”+“b” a和b是否相等
相等，用字面量形式创建的字符串会搜索字符串常量池，如果没找到会创建一个新的。
如果使用new方法则总是会新创建一个对象。可以使用intern方法手动将其放入字符串常量池。此优化的前提条件是java字符串的不可变性，不会被错误篡改。字符串常量池内部实现是hashmap，会消耗cpu。字符串常量池在永久代中，存的是弱引用，不会影响gc。
13. 接上一题，总共会创建几个对象
一个对象，编译期间会处理字符串拼接。
14. int a=1是否是原子操作
是
15. 给线程池新加一个任务，线程池会如何处理。
首先尝试让corethreads处理，失败则进队列，队列满则创建新的工作线程，再失败则交给饱和策略处理
16. aqs和cas原理
aqs使用cas加volatile加双向队列实现。具体实现依赖异步算法
cas在写操作前会比较当前值和预期值是否相等，如果不相等则进行重试。实现依赖CPU指令是原子操作。
17. synchronize的实现原理
通过monitorenter和monitorexit指令来获取和释放对象的monitor锁
monitor锁信息报存在对象头的markword中markword默认保存对象的hashcode以及分代年龄。当线程持有锁后，markword的lock record指针会指向线程的monitor record。monitor record是线程私有的数据，保存owner 线程id nest自旋计数 候选线程号等信息。偏向锁和轻量锁使用cas竞争锁，重量级锁会阻塞线程。偏向锁存在竞争会膨胀为轻量锁，轻量锁自旋一定次数会转换为重量级锁。
18. volalite关键字的所用
保证变量可见性，禁止重排序
19. aop和ioc原理
aop使用代理模式实现 ，代理分为静态代理和动态代理。ioc，将对象的控制权交给spring。程序直接使用即可，无需创建。
20. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？
引用不能变，实际对象的值还是能变的
21. string能被继承吗
不能 string对象是final的
22. string stringbuilder stringbuffer的区别
string不可变。stringbuffer线程安全  stringbuilder线程不安全
23. arraylist和linklist的区别
array list底层是数组，元素访问时间为o1 linklist访问为on。linklist插入操作比较快 只需更新指针，arraylist需要扩容和更新索引。linklist更加消耗内存，因为要多存两个指针。
24. 用过哪些 Map 类，都有什么区别，HashMap 是线程安全的吗,并发下使用的 Map 是什么，他们内部原理分别是什么，比如存储方式， hashcode，扩容， 默认容量等。
hashtable是遗留类并发使用concurrrenthashmap。hashmap使用数组加链表加红黑树实现。新增元素会使用高位参与的mod算法计算出桶索引，同时为了优化mod算法的速度，桶的长度必须是二的n次方大小。因为对二的n次方的取余操作可以用速度更快的位与操作代替。当桶内发生hash碰撞时，桶内元素会转换成链表。如果链表过长会转换成红黑树。读写操作时间复杂度分别为o1on和olgn。hashmap的扩容操作发生在put中触发条件由负载率参数控制。扩容后元素会重新分布，过程也收益与桶大小是2的n次方。
25. Spring框架中的单例bean是线程安全的吗
不安全
26. sleep和wait的区别
sleep是线程方法，挂起线程给其他线程执行时间，sleep不会释放线程拥有的对象锁 wait是object的方法，会释放对象锁锁 wait必须使用notify或者notify all来恢复运行
27. tcp如何进行流量控制的
tcp使用滑动窗口来进行流量控制。接收端使用win字段通知发送端最多可以发送多少未经确认的字节。发送端会维护一个窗口结构
。窗口结构分为四部分，分别问已发送已确认，已发送未确认，未发送已就绪和不能发送。当收到接收端的新ack时，如果win大小没有变化，此时窗口就会向右滑动。接受端也会维护一个窗口结构，保存已接收已确认和可以接受的最大序列号。当发送端收到一个零窗口通知时，会启动窗口探测机制，间歇性地去询问可用窗口情况。窗口探测机制是为了防止窗口更新包丢失导致的长时间等待。
28. java int和integer的区别
integer是int的包装类，目标是可以向操作java普通类型那样操作原始类型。java1.5开始支持自动拆箱和装箱操作。在将string转换成整型时应该根据目标类型选择正确的方法。valueof返回integer类型，parseint返回int类型
29. 什么是Callable和Future?
callable是带有返回值的runnable。可以通过future异步得获取callable的运行结果
30. java守护线程和本地线程的区别
守护线程在所用用户线程退出时也会退出。javagc线程就是守护线程
31. 什么是多线程cpu切换
当线程数量大于cpu数量时，为了使所有线程都获取执行时间，cpu会在线程间进行切换。
32. 为什么使用线程池
提供线程管理功能，能够重复利用线程，节省线程创建的消耗。提供门面，简化多线程编程。
33. Object类的equal和hashCode方法重写，为什么？














 
